<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style type="text/css">
    :root {
      /* Colors */
      --color-grey-50: #fafafa;
      --color-grey-500: #9e9e9e;
      --color-grey-800: #424242;
      --color-grey-900: #212121;
      --color-bluegrey-900: #263238;
      --color-background: var(--color-grey-900);
      --color-foreground: var(--color-grey-50);

      /* Spacing */
      --spacing-half: 4px;
      --spacing-1: 8px;
      --spacing-2: 16px;
      --spacing-3: 24px;
      --spacing-4: 32px;
    }

    html {
      height: 100%;
    }

    body {
      min-height: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-family: Verdana, sans-serif;
      color: var(--color-foreground);
      background: var(--color-background);
    }

    h1,
    h2,
    h3 {
      font-family: Helvetica, sans-serif;
    }

    .text--small {
      font-size: 0.8em;
    }

    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-grow: 1;
    }

    #canvas {
      border: 1px solid var(--color-grey-800);
      cursor: pointer;
    }

    .footer {
      margin-top: var(--spacing-4);
      display: flex;
      flex-wrap: wrap;
      justify-content: space-evenly;
      padding: var(--spacing-3);
    }

    .footer a {
      color: var(--color-grey-500);
      padding: var(--spacing-1);
    }
  </style>

  <title>Elementary Cellular Automata</title>
</head>
<body>
  <section class="content">
    <canvas id="canvas" onclick="main()">
      Your browser doesn't support canvas
    </canvas>
    <p class="text--small">Tap, click or refresh to update</p>
  </section>
  <section class="footer">
    <a class="text--small" href="https://en.wikipedia.org/wiki/Elementary_cellular_automaton">
      WTF am I looking at?
    </a>
    <a class="text--small" href="https://github.com/ruslan-sh/cellular-automata">GitHub</a>
  </section>
  <script>
    function shuffle(array) {
      var m = array.length, t, i;
      // While there remain elements to shuffle…
      while (m) {
        // Pick a remaining element…
        i = Math.floor(Math.random() * m--);

        // And swap it with the current element.
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    class Automata {
      constructor(conf) {
        if (conf.base < 2 || 8 < conf.base) {
          throw 'Invalid Input';
        }
        const rulesCount = Math.pow(conf.base, conf.inputSize);
        if (Math.pow(conf.base, rulesCount) < conf.ruleIndex) {
          throw 'Invalid Input';
        }
        const rulesArray = new Array(rulesCount);
        let convert = conf.ruleIndex;
        for (let i = 0; i < rulesCount; i++) {
          rulesArray[i] = convert % conf.base;
          convert = parseInt(convert / conf.base);
        }

        this.base = conf.base;
        this.inputSize = conf.inputSize;
        this.rules = rulesArray;
      }

      invoke(input) {
        const size = input.length;
        const output = new Array(size);
        for (let i = 0; i < size; i++) {
          let ruleIndex = 0;
          for (let j = 0; j < this.inputSize; j++) {
            let inputIndex = i + j - parseInt(this.inputSize/2);
            if (inputIndex < 0) {
              inputIndex = size + inputIndex;
            }
            if (size <= inputIndex) {
              inputIndex = inputIndex - size;
            }
            ruleIndex = ruleIndex * this.base + input[inputIndex];
          }
          output[i] = this.rules[ruleIndex];
        }
        return output;
      }

      getInputRow(inputType, size) {
        const centralPoint = () => {
          const result = new Array(size).fill(0);
          result[parseInt(size/2)] = 1;
          return result;
        }

        const even = () => {
          let result = [];
          let baseLeft = this.base;
          let sizeLeft = size;
          while (0 < baseLeft) {
            const tmpSize = parseInt(sizeLeft/baseLeft);            
            baseLeft--;
            result = result.concat(new Array(tmpSize).fill(baseLeft));
            sizeLeft -= tmpSize;
          }
          return result;
        }

        const interchange = () => {
          const result = new Array(size).fill(0); 
          for (let i = 1; i < size; i++) {
            result[i] = i % this.base;
          }
          return result;
        }

        const randomEven = () => {        
          return shuffle(even());
        }

        const random = () => {
          const result = new Array(size).fill(0);
          for (let i = 0; i < size; i++) {
            result[i] = Math.floor(Math.random() * this.base); 
          }
          return result;
        }

        switch (inputType) {
          case 'center':
            return centralPoint();
          case 'even':
            return even();
          case 'interchange':
            return interchange();
          case 'random-even':
            return randomEven();
          default:
            return random();
        }
      }

      static getRandomRule(conf) {
        return Math.floor(Math.random() * Math.pow(conf.base, Math.pow(conf.base, conf.inputSize)));
      }
    }

    class Display {
      constructor(conf) {
        this.size = conf.size;
        this.zoom = conf.zoom;
        this.colors = conf.colors;

        const canvas = document.getElementById('canvas');
        canvas.height = this.size * this.zoom;
        canvas.width = this.size * this.zoom;
        this.context = canvas.getContext('2d');
      }

      drawRow(rowIndex, row) {
        const y = rowIndex * this.zoom;
        for (let i = 0; i < row.length; i++) {
          const x = i * this.zoom;
          this.context.fillStyle = this.colors[row[i]];
          this.context.fillRect(x, y, this.zoom, this.zoom);
        }
      }

      static getRandomColors() {
        const colors = [
          '#FAFAFA', // black
          '#212121', // white
          '#F44336', // red
          '#4CAF50', // green
          '#2196F3', // blue
          '#FFEB3B', // yellow
          '#9C27B0', // purple
          '#00BCD4', // cyan
          ];
          return shuffle(colors);
        }
      }

      function main() {
        const automataConf = {
          base: 3,
          inputSize: 3,
          ruleIndex: 0,
        };    
        automataConf.ruleIndex = Automata.getRandomRule(automataConf);
        console.log(automataConf.ruleIndex);
        const automata = new Automata(automataConf);
        
        const displayConf = {       
          size: 360,
          zoom: 2,
          colors: Display.getRandomColors(),
        }
        const display = new Display(displayConf);
        
        let row = automata.getInputRow('random-even', displayConf.size);
        display.drawRow(0, row);
        for (let i = 1; i < displayConf.size; i++) {
          row = automata.invoke(row);
          display.drawRow(i, row);
        }
      }

      main();
    </script>
  </body>
  </html>
